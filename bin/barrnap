#!/usr/bin/env perl
use 5.32.0;
use strict;
use warnings;
use Cwd qw"abs_path";
use List::Util qw"min max";
use List::MoreUtils qw"uniq minmax";
use FindBin;
use File::Temp qw"tempdir";
use File::Basename;
use File::Spec;
use File::Path qw"make_path";
use Data::Dumper;

# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
# global variables

my $VERSION = "1.4.5";
my $EXE = $FindBin::RealScript;
my $DESC = "Rapid micrboial rRNA/tRNA/ncRNA prediction";
my $AUTHOR = 'Torsten Seemann';
my $URL = 'https://github.com/tseemann/barrnap';
my $DEFAULT_DBDIR = abs_path("$FindBin::RealBin/../db");
my $BUILD_DIR = abs_path("$FindBin::RealBin/../build");
my $DEVNULL = File::Spec->devnull;
my $DOT = '.';
my @KINGDOM = qw"bac arc fun";
my %KINGDOM = (map { $_ => 1 } @KINGDOM);

my %SNAME = (
  'RF00001' => "5S",  'RF00002' => "5.8S",
  'RF00177' => "16S", 'RF01959' => "16S",
  'RF01960' => "18S", 'RF02540' => "23S",
  'RF02541' => "23S", 'RF02543' => "28S",
);

# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
# command line options

my(@Options, 
   $quiet, $kingdom, $threads, $legacy,
   $fast, $debug, $rrna, $trna, $ncrna,
   $operon, $opdist, $addids, 
   $listdb, $updatedb, $dbdir,
   $evalue, $lencutoff, $reject,
   $incseq, $incseqreg, $outseq, 
);
setOptions();

# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
# check all is well

#-d $dbdir or err("--dbdir '$dbdir' does not exist");

$listdb and list_dbs($dbdir);
$updatedb and update_dbs($dbdir);

@ARGV or err("No input sequence files provided");

$trna || $rrna || $ncrna or err("Must choose at least one of --rrna --trna --ncrna");
$threads > 0 or err("Invalid --threads $threads");
$evalue > 0 or err("Invalid --evalue $evalue");
$lencutoff > 0 or err("Invalid --lencutoff $lencutoff");
$reject > 0 or err("Invalid --reject cutoff $reject");

exists $KINGDOM{$kingdom} or
  err("Imvalid --kingdom '$kingdom'. Try:", values(%KINGDOM) );
# FIXME: store with --kingdom database  
my $code = $kingdom =~ m/^(bac|arc)$/ ? 11 : 1;

msg("This is $EXE $VERSION by $AUTHOR");
msg("Obtained from $URL");

if ($legacy) {
  msg("Swiching to legacy barrnap < 1.0 mode");
  $rrna=1;
  $trna = $ncrna = $operon = 0;
}
msg("Checking dependencies:");
require_exe(
  'cmsearch', 'bedtools', 'aragorn', 
  'any2fasta', 'seqkit', 'make'
);

# Check all input files and make
my @infile;
for my $infile (uniq @ARGV) {
  $infile = '/dev/stdin' if $infile eq '-';
  -r $infile or err("Can't read file: $infile");
  push @infile, quotemeta File::Spec->rel2abs($infile);
}
@infile or err("No input files provided.");
dbg( Dumper(\@infile) );

# Make a temp folder for all intermediate files
my $tempdir = $debug ? $DOT : tempdir(CLEANUP=>1);
chdir($tempdir);

# Write a single combined FASTA file
my $FASTA = "$EXE.fasta";
my($a2f_opt,$sk_opt) = $quiet ? ('-q','--quiet') : ('','');
run_cmd("any2fasta -k $a2f_opt @infile > $FASTA.tmp");
run_cmd("seqkit seq $sk_opt -g --min-len 1 -u -w 60 $FASTA.tmp > $FASTA");
-s $FASTA or err("No sequences found in input");
run_cmd("rm -f $FASTA.fai"); # for --debug case of tmp=.
run_cmd("seqkit faidx $sk_opt $FASTA");

# Loop over the RNA types chosen to scan
my @gff;
if ($trna) {
  my $toolver = aragorn_version();
  my $ara_file = run_aragorn($FASTA, $code);
  push @gff, parse_aragorn($ara_file, $toolver);
}
if ($rrna) {
  my $tool = 'cmsearch';
  my $tbl_file = run_infernal($tool, $FASTA, $kingdom, 'rRNA');
  push @gff, parse_infernal($tool, $tbl_file, 'rRNA');;
}
if ($operon) {
  @gff = sort_gff(\@gff); # for bedtools
  push @gff, find_operons(\@gff);
}
if ($ncrna) {
  my $exe = 'cmscan';
  my $tbl_file = run_infernal($exe, $FASTA, $kingdom, 'ncRNA');
  push @gff,parse_infernal($exe, $tbl_file, 'ncRNA');
}
msg("Found", 0+@gff, "features.");

@gff = sort_gff(\@gff);
gff_add_ids(\@gff) if $addids;
print_gff(\*STDOUT, \@gff, $incseq, $incseqreg);

msg("Done.");

#----------------------------------------------------------------------
sub gff_add_ids {
  my($feats) = @_;
  my %count;
  for my $f (@$feats) {
    my $nv = $f->[-1]; # tagsin last column
    my $t = $nv =~ m/Name=([^;]+)/ ? $1 : $f->[2];
    $t =~ s/\s/_/g;
    $count{$t}++; 
    $f->[-1] = join ';', "ID=$t-$count{$t}", $nv;
  }
}
#----------------------------------------------------------------------
sub find_operons {
  my($feats) = @_;
  my @operons;
  my $outf = "$EXE.find_operon.gff";
  open my $fh, '>', $outf;
  print_gff($fh, $feats, 0, 0);
  my $inf = "$EXE.operon.bed";
  run_cmd("bedtools merge -s -d $opdist -i $outf" 
         ." -c 3 -o count,collapse -delim '-'"
         ." > $inf");
  open my $BED, '<', $inf;
  while (<$BED>) {
    chomp;
    my @bed = split m/\t/;
    next unless $bed[3] > 1; # not singletons
    # this makes tRNA-only operons too.
    my $name = $bed[4] =~ /rRNA/ ? 'rRNA' : 'tRNA';
    my($b,$e,$s) = bed2gff_coords($bed[1],$bed[2]);
    push @operons, [
      $bed[0],
      "$EXE:$VERSION",
      'operon',
      $b, $e, $DOT, $s, $DOT,
      "Name=$name operon;product=$name operon: $bed[4]"
    ];
  }
  return @operons;
}
#----------------------------------------------------------------------
sub write_bed {
  my($fh, $gff) = @_;
  # $gff =  arrayref of gff arrays
  foreach (@$gff) {
  # https://en.wikipedia.org/wiki/General_feature_format#GFF_general_structure
  # https://en.wikipedia.org/wiki/BED_(file_format)#Format
    print {$fh} tsv(
      $_->[0],   # chr
      $_->[3]-1, # begin 0-based
      $_->[4],   # end (exclusive)
      $DOT,      # name
      1000,      # socre 1-1000
      $_->[6],   # strand
    );
  }
}
#----------------------------------------------------------------------
sub bed2gff_coords {
  my($begin,$end) = @_;
  return (
    min($begin,$end) + 1,
    max($begin,$end),
    $begin > $end ? '-' : '+',
  )
}
#----------------------------------------------------------------------
sub gff2bed_coords {
  my($start,$finish,$strand) = @_;
  return $strand eq '+' 
         ? ($start-1,$finish)
         : ($finish-1,$start);
}
#----------------------------------------------------------------------
sub tsv {
  return join("\t",@_)."\n";
}
#----------------------------------------------------------------------
sub gff_cmp {
  return ($a->[0] cmp $b->[0])   # name
      || ($a->[3] <=> $b->[3])   # start
      || ($b->[4] <=> $a->[4]) ; # end (rev)
}
#----------------------------------------------------------------------
sub sort_gff {
  my($gff) = @_;
  return sort { &gff_cmp } @$gff; 
}
#----------------------------------------------------------------------
sub print_gff {
  my($fh, $feats, $add_seq, $add_seq_reg) = @_;
  select $fh;
  $fh->autoflush(1);
  print "##gff-version 3\n";
  if ($add_seq_reg) {
    run_cmd(
       "seqkit fx2tab --only-id --name --length $FASTA"
     ." | sed 's/\\t/ 1 /'"
     ." | sed 's/^/##sequence-region /'"
    );
  }
  # print each feature line (assymeed sorted)
  for my $row (@$feats) {
     print tsv(@$row);
  }
  if ($add_seq) {
    print "##FASTA\n";
    run_cmd("cat $FASTA");
  }
  $fh->close();

  if ($outseq) {
#   msg("Writing hit sequences to: $outseq");
    my $BED = "$EXE.bed";
    open my $bed, '>', $BED;
    write_bed($bed, \@gff); # write ALL features
    close $bed;
    my $bq = $quiet ? "2>$DEVNULL" : "";
    run_cmd("bedtools getfasta -s -fo \Q$outseq\E -fi $FASTA -bed $BED $bq");
  } 
}
#----------------------------------------------------------------------
sub run_aragorn {
  my($fasta, $code) = @_;
  my $outfile = "$fasta.aragorn.out";
  my $cmd = "aragorn -w -gc$code -o '$outfile' '$fasta'";
  run_cmd($cmd);
  return $outfile;
}
#----------------------------------------------------------------------
sub aragorn_version {
  #----------------------------
  #ARAGORN v1.2.41 Dean Laslett
  #----------------------------
  my $help = join '', qx"aragorn -h";
  $help =~ m/(ARAGORN) v([\d\.]+)/s or err("Can not parse aragorn version");;
  return lc($1).":$2";
}
#----------------------------------------------------------------------
sub parse_aragorn {
  my($fname, $toolver) = @_;
  $toolver ||= "$EXE:$VERSION";
  my %PROD = (
    'tRNA'   => 'trasnfer RNA',
    'tmRAN'  => 'transfer-meesenger RNA',
#    'tmRNA*' => 'circularly
  );
  my @gff;
  #>AL123456
  #54 genes found
  #1   tRNA-Ile    [10887,10961]   35     (gat)
  #2   tRNA-Ala    [11112,11185]   34     (tgc)
  #3   tRNA-Leu    [25644,25728]   34     (cag
  #4   tRNA-Ser   c[243100,243188] 35     (gga)
  #46  tmRNA       [753615,753977] 90,125 ANDENYALAA**
  open my $fh, '<', $fname;
  my $seqid;
  while (<$fh>) {
    chomp;
    if (m/^>(\S+)/) {
      $seqid = $1;
    }
    elsif (m/genes/) {
      next;
    }
    else {
      my @x = split ' ', $_;
      $x[2] =~ m/(c?)\[(\d+),(\d+)\]/;
      my($begin,$end) = ($2,$3);
      my $strand = $1 ? '-' : '+';

      my $odd=0;
      if ($x[1] =~ m/\*$/) {
        $odd=1;
        chop $x[1];
      }
      my $name = $x[1];
      $name =~ m/^(\w+)/;
      my $type = $1;
      my $prod = $type eq 'tRNA' 
               ? 'transfer RNA' 
               : 'transfer-messenger RNA';
      $prod .= " (non-canonical)" if $odd;

      my $score = $DOT;
      push @gff, [
        $seqid, $toolver,
        $type, $begin, $end,
        $score, $strand,  $DOT,
        "Name=$name;product=$prod $x[4]"
      ];
    }
  }
  return @gff;
}
#----------------------------------------------------------------------
sub run_infernal {
  my($exe, $fasta, $king, $feat) = @_;
  my $outfile = "$fasta.$king.$feat.tbl";
  my $speed = $fast ? "--hmmonly" : "--rfam -g";
  my $cmd = "$exe $speed";
  $cmd .= " --cpu $threads -E $evalue";
  $cmd .= " --tblout $outfile";
  $cmd .= " --noali -o $DEVNULL";
  # the 2 positional parametrs
  $cmd .= " $dbdir/$king/$king.$feat.cm";
  $cmd .= " $fasta";
  run_cmd($cmd);
  return $outfile;
}
#----------------------------------------------------------------------
sub parse_infernal {
  my($exe, $fname, $ftype) = @_;
  my $toolver = "$EXE:$VERSION"; # will overide later
  my @gff;
  open my $fh, '<', $fname;
  while (<$fh>) {
    chomp;
    # # Version:         1.1.5 (Sep 2023)
    if (m/Version:\s+([\d\.]+)/) {
      $toolver = "infernal:$1";
    }
    next if m/^#/;    # comment line
    next if m/^\s*$/; # empty line
    
    my @x = split ' ', $_;
    dbg( map { "[$_]='$x[$_]' " } 0 .. $#x );

    my $strand = $x[9];
    $strand =~ m/^[+-]$/ or err("Bad hit line: @x");
    my($begin,$end) = minmax($x[7], $x[8]);
    my $prod = join( ' ', @x[17..$#x] );
    my $score = $x[15] // $DOT;

    # label = $seqid  $seqaccd $model   $mode;_acc
    # rRMA  = E.coli  -        5S_rRNA  RF00001
    # mcRMA = AsrC    RF02746  E.coli   -
    if ($exe eq 'cmscan') {
      my @pair = splice @x, 2, 2;
      unshift @x, @pair;
    }
    else { # exe eq 'cmsearch'
      $x[2] =~ m/^([^_]+)/;
      $prod = "$1 ribosomal RNA";
    }
    my($seq_id, $model_id, $model_acc) = ($x[0], $x[2], $x[3]);

    my $names = "Name=$model_id";
    if ($ftype eq 'rRNA') {
      my $sname = $SNAME{$model_acc} or err("No 'S' name for $model_acc");
      $names = "Name=${sname}_rRNA;Alias=$model_id";
      $prod = "$sname ribosomal RNA";
    }

    msg("Found $ftype $model_id($model_acc) @ $seq_id:$begin-$end($strand)"); 

    push @gff, [
      $seq_id, 
      $DOT, # will patch in true version at end
      $ftype,
      $begin, $end, $score, $strand,$DOT, 
        $names
       .";Dbxref=Rfam:$model_acc"
       .";product=$prod"
    ];
  }
  # fill in the tool version (came after featreus)
  map { $_->[1] = $toolver } @gff;
  return @gff;
}
#----------------------------------------------------------------------
sub run_cmd {
  my($cmd) = @_;
  msg("Running: $cmd");
  system($cmd)==0 or err("COuld not run: $cmd");
}
#----------------------------------------------------------------------
sub enumerate_dbs {
  my($dir) = @_;
  $dir // err("Can't enumerate undefined folder");
  my $db = {};
  for my $cm (glob("$dir/*/*.cm")) {
    $cm =~ m=(\w+)\.(\w+)\.cm$= or err("Bad mode; $cm");
    $db->{$1}{$2} = $cm;
  }
  return $db;
}
#----------------------------------------------------------------------
sub list_dbs {
  my $d = shift // $dbdir;
  my $dbs = enumerate_dbs($d);
  msg("Database home: $d");
  my $count=0;
  for my $k (sort keys %$dbs) {
    msg("--kingdom '$k' has: tRNA tmRNA",sort keys %{$dbs->{$k}});;
    $count++;
  }
  $count or err("You have no databases installed!"
   ."\nRun '$EXE --updatedb' to update/repair thos");
  exit(0);
}
#----------------------------------------------------------------------
sub update_dbs {
  my $d = shift // $dbdir;
  if (! -d $d) {
    msg("Making folder: $d");
    make_path($d);
  }
  -d $d or err("Database folder: $d does not exist");
  -w $d or err("You don't have permissions to modify the database folder: $dbdir");
  my $make = "make -j $threads -C \Q$BUILD_DIR\E DBDIR=\Q$d\E";
  run_cmd("$make bigclean");
  run_cmd("$make install");  
  list_dbs($d);
  #msg("Finished updating databases.");
  exit(0);
}
#----------------------------------------------------------------------
sub require_exe {
  for my $exe (@_) {
    my($which) = qx"which $exe 2>$DEVNULL";
    $which or err("Can not find required '$exe' in PATH");
    chomp $which;
    msg("Found $exe - $which");
  }
}
#----------------------------------------------------------------------
sub msg {
  return if $quiet;
  my $line = "[$EXE] @_\n";
  print STDERR $line;
}
#----------------------------------------------------------------------
sub dbg {
  print STDERR "[$EXE] DEBUG:\n", @_,"\n" if $debug;
}
#----------------------------------------------------------------------
sub err {
  $quiet=0;
  msg("ERROR:", @_);
  exit(2);
}
#----------------------------------------------------------------------
sub version {
  print "$EXE $VERSION\n";
  exit;
}
#----------------------------------------------------------------------
sub show_citation {
  print STDERR << "EOCITE";
  
If you use Barrnap in your work, please cite:

    Seemann T
    $EXE $VERSION : $DESC
    $URL
    
Thank you.

EOCITE

  exit;
}
#----------------------------------------------------------------------
# Option setting routines

sub setOptions {
  use Getopt::Long;

  @Options = (
    'GENERAL',
    {OPT=>"help",    VAR=>\&usage,             DESC=>"This help"},
    {OPT=>"version", VAR=>\&version,           DESC=>"Print version and exit"},
    {OPT=>"citation",VAR=>\&show_citation,     DESC=>"Print citation for referencing $EXE"},
    {OPT=>"quiet!",  VAR=>\$quiet, DESC=>"No screen output"},
    {OPT=>"debug!",  VAR=>\$debug, DESC=>"Debug mode"},
    'DATABASE',
    {OPT=>"listdb", VAR=>\$listdb, DESC=>"Show installed database"},
    {OPT=>"updatedb", VAR=>\$updatedb, DESC=>"Update databases from internet"},
    {OPT=>"dbdir=s", VAR=>\$dbdir, DEFAULT=>$DEFAULT_DBDIR, DESC=>"Location of databases"},
    "MODE",
    {OPT=>"kingdom=s", VAR=>\$kingdom, DEFAULT=>'bac', DESC=>"Kingdom: ".join(',', keys %KINGDOM) },
    {OPT=>"legacy!", VAR=>\$legacy,  DEFAULT=>0, DESC=>"Simulate barrnap<1.0 - only --rrna)" },
    {OPT=>"rrna!",  VAR=>\$rrna, DEFAULT=>1, DESC=>"Find rRNA, disable with --no-rrna" },
    {OPT=>"trna!",  VAR=>\$trna, DEFAULT=>1, DESC=>"Find tRNA/tmRNA, disable with --no-trna" },
    {OPT=>"ncrna!", VAR=>\$ncrna, DEFAULT=>1, DESC=>"Find ncRNA, disable with --no-ncrna" },
    {OPT=>"operon!", VAR=>\$operon, DEFAULT=>1, DESC=>"Idenitfy RNA opersons, disanle wioth --no-operson" },
    {OPT=>"opdist=i", VAR=>\$opdist, DEFAULT=>200,  DESC=>"Operon clustering threshold" },
    "SPEED",
    {OPT=>"threads=i", VAR=>\$threads, DEFAULT=>1,  DESC=>"CPU cores to use"},
    {OPT=>"fast!", VAR=>\$fast, DEFAULT=>undef,  DESC=>"Trade speed for accuracy"},
    "FILTERING",
    {OPT=>"lencutoff=f",VAR=>\$lencutoff, DEFAULT=>0.8, DESC=>"Proportional length threshold to label as partial"},
    {OPT=>"reject=f",VAR=>\$reject, DEFAULT=>0.25, DESC=>"Proportional length threshold to reject prediction"},
    {OPT=>"evalue=f",VAR=>\$evalue, DEFAULT=>0.001, DESC=>"Similarity e-value cut-off"},
    "GFF OUTPUT",
    {OPT=>"addids!",  VAR=>\$addids,  DESC=>"Add unique ID tagsn" },
    {OPT=>"incseq!",  VAR=>\$incseq,  DESC=>"Include original input sequences"},
    {OPT=>"incseqreg!",  VAR=>\$incseqreg,  DESC=>"Include #sequence-region headers"},
    {OPT=>"outseq=s",  VAR=>\$outseq,  DESC=>"Save RNA hits to a FASTA file"},
  );

  my @opt = ( map { $_->{OPT}, $_->{VAR} } 
               grep { ref }  @Options );
  GetOptions(@opt) or exit(1);

  # Now setup default values.
  foreach (@Options) {
    if (ref $_ && defined($_->{DEFAULT}) && !defined(${$_->{VAR}})) {
      ${$_->{VAR}} = $_->{DEFAULT};
    }
  }
}

#----------------------------------------------------------------------
sub usage {
  my($exitcode) = @_;
  $exitcode = 0 if $exitcode eq 'help'; # what gets passed by getopt func ref
  $exitcode ||= 0;
  select STDERR if $exitcode; # write to STDERR if exitcode is error

  print "NAME\n";
  print "  $EXE $VERSION\n";
  print "SYNOPSIS\n";
  print "  $DESC\n";
  print "USAGE\n";
  print "  $EXE [opts] seq.{fa,gbk,fq}[.gz] ... \n";
  foreach (@Options) {
    if (ref $_) {
      my $def = defined $_->{DEFAULT} ? "[$_->{DEFAULT}]" : "";
      my $opt = $_->{OPT};
      if ($opt =~ s/!$//) {
        $def = $_->{DEFAULT} ? "[on]" : "";
      }
      $opt =~ s/=s$/ STR/;
      $opt =~ s/=i$/ INT/;
      $opt =~ s/=f$/ NUM/;
      printf "  --%-13s %s %s\n", $opt, $_->{DESC}, $def;
    }
    else {
      print "$_\n";
    }
  }
  print "HOMEPAGE\n";
  print "  $URL";
  exit($exitcode);
}

#---------------------------------------------------------------------
