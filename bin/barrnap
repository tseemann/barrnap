#!/usr/bin/env perl
use 5.32.0;
use strict;
use warnings;
use Cwd qw"fast_abs_path";
use List::Util qw"min max";
use List::MoreUtils qw"uniq";
use FindBin;
use File::Temp qw"tempdir";
use File::Basename;
use File::Spec;
use Data::Dumper;

# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
# global variables

my $VERSION = "1.2.1";
my $EXE = $FindBin::RealScript;
my $DESC = "Rapid micrboial rRNA/tRNA/ncRNA prediction";
my $AUTHOR = 'Torsten Seemann';
my $URL = 'https://github.com/tseemann/barrnap';
my $DBDIR = fast_abs_path("$FindBin::RealBin/../db");
my $DEVNULL = File::Spec->devnull;
my $DOT = '.';

my $dbs = enumerate_dbs($DBDIR);

my %KINGDOM = (map { $_ => 1 } 
  sort keys %$dbs );

# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
# command line options

my(@Options, $quiet, $kingdom, $threads, 
  $listdb, $setupdb, $fast, $debug, 
  $operon, $opdist,
  $evalue, $lencutoff, $reject, $incseq, 
  $incseqreg, $outseq, $trna, $rrna, $ncrna);
setOptions();

# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
# check all is well

@ARGV or err("No input sequence files provided");

msg("This is $EXE $VERSION by $AUTHOR");
msg("Obtained from $URL");

msg("Checking dependencies:");
require_exe('cmsearch', 'bedtools', 'aragorn', 'any2fasta');

$trna || $rrna || $ncrna or err("Must choose at least one of --rrna --trna --ncrna");
$threads > 0 or err("Invalid --threads $threads");
$evalue > 0 or err("Invalid --evalue $evalue");
$lencutoff > 0 or err("Invalid --lencutoff $lencutoff");
$reject > 0 or err("Invalid --reject cutoff $reject");

exists $KINGDOM{$kingdom} or
  err("Imvalid --kingdom '$kingdom'. Try:", values(%KINGDOM) );
# FIXME: store with --kingdom database  
my $code = $kingdom =~ m/^(bac|arc)$/ ? 11 : 1;

# Check all input files and make
my @infile;
for my $infile (uniq @ARGV) {
  $infile = '/dev/stdin' if $infile eq '-';
  -r $infile or err("Can't read file: $infile");
  push @infile, quotemeta File::Spec->rel2abs($infile);
}
@infile or err("No input files provided.");
dbg( Dumper(\@infile) );

# Make a temp folder for all intermediate files
my $tempdir = $debug ? $DOT : tempdir(CLEANUP=>1);
chdir($tempdir);

# Write a single combined FASTA file
my $FASTA = "$EXE.fasta";
my($a2f_opt,$sk_opt) = $quiet ? ('-q','--quiet') : ('','');
run_cmd("any2fasta -k $a2f_opt @infile > $FASTA.tmp");
run_cmd("seqkit seq $sk_opt -g --min-len 1 -u -w 60 $FASTA.tmp > $FASTA");
-s $FASTA or err("No sequences found in input");
run_cmd("rm -f $FASTA.fai"); # for --debug case of tmp=.
run_cmd("seqkit faidx $sk_opt $FASTA");

# Loop over the RNA types chosen to scan
my @gff;
if ($trna) {
  my $ara_file = run_aragorn($FASTA, $code);
  push @gff, parse_aragorn($ara_file);
}
if ($rrna) {
  my $tbl_file = run_infernal("cmsearch", $FASTA, $kingdom, 'rRNA');
  push @gff, parse_infernal($tbl_file, 'rRNA');;
}
if ($operon) {
  @gff = sort_gff(\@gff); # for bedtools
  push @gff, find_operons(\@gff);
}
if ($ncrna) {
  #my $tbl_file = run_infernal("cmscan", $FASTA, $kingdom, 'ncRNA');
  #push @gff,parse_infernal($tbl_file, $type);
  msg("WARNING: --ncrna not yet supported");
}
msg("Found", 0+@gff, "features.");

@gff = sort_gff(\@gff);
print_gff(\*STDOUT, \@gff, $incseq);

msg("Done.");

#----------------------------------------------------------------------
sub find_operons {
  my($feats) = @_;
  my @operons;
  my $outf = "$EXE.gff";
  open my $fh, '>', $outf;
  print_gff($fh, $feats, 0);
  my $inf = "$EXE.operon.bed";
  run_cmd("bedtools merge -s -d $opdist -i $outf" 
         ." -c 3 -o count,collapse -delim '-'"
         ." > $inf");
  open my $BED, '<', $inf;
  while (<$BED>) {
    chomp;
    my @bed = split m/\t/;
    next unless $bed[3] > 1; # not singletons
    my $name = $bed[4] =~ /rRNA/ ? 'rRNA' : 'tRNA';
    my($b,$e,$s) = bed2gff_coords($bed[1],$bed[2]);
    push @operons, [
      $bed[0],
      "$EXE:$VERSION",
      'operon',
      $b,
      $e,
      $DOT,
      $s,
      "Name=$name operon;product=$bed[4]"
    ];
  }
  return @operons;
}
#----------------------------------------------------------------------
sub write_bed {
  my($fh, $gff) = @_;
  # $gff =  arrayref of gff arrays
  foreach (@$gff) {
  # https://en.wikipedia.org/wiki/General_feature_format#GFF_general_structure
  # https://en.wikipedia.org/wiki/BED_(file_format)#Format
    print {$fh} tsv(
      $_->[0],   # chr
      $_->[3]-1, # begin 0-based
      $_->[4],   # end (exclusive)
      $DOT,      # name
      1000,      # socre 1-1000
      $_->[6],   # strand
    );
  }
}
#----------------------------------------------------------------------
sub bed2gff_coords {
  my($begin,$end) = @_;
  return (
    min($begin,$end) + 1,
    max($begin,$end),
    $begin > $end ? '-' : '+',
  )
}
#----------------------------------------------------------------------
sub gff2bed_coords {
  my($start,$finish,$strand) = @_;
  return $strand eq '+' 
         ? ($start-1,$finish)
         : ($finish-1,$start);
}
#----------------------------------------------------------------------
sub tsv {
  return join("\t",@_)."\n";
}
#----------------------------------------------------------------------
sub gff_cmp {
  return ($a->[0] cmp $b->[0])   # name
      || ($a->[3] <=> $b->[3])   # start
      || ($b->[4] <=> $a->[4]) ; # end (rev)
}
#----------------------------------------------------------------------
sub sort_gff {
  my($gff) = @_;
  return sort { &gff_cmp } @$gff; 
}
#----------------------------------------------------------------------
sub print_gff {
  my($fh, $feats, $add_seq) = @_;
  select $fh;
  print "##gff-version 3\n";
  if ($incseqreg) {
    run_cmd(
       "seqkit fx2tab --only-id --name --length $FASTA"
     ." | sed 's/\\t/ 1 /'"
     ." | sed 's/^/##sequence-region /'"
    );
  }
  # print each feature line (assymeed sorted)
  for my $row (@$feats) {
     print tsv(@$row);
  }
  if ($add_seq) {
    print "##FASTA\n";
    run_cmd("cat $FASTA");
  }
  if ($outseq) {
#   msg("Writing hit sequences to: $outseq");
    my $BED = "$EXE.bed";
    open my $bed, '>', $BED;
    write_bed($bed, \@gff);
    close $bed;
    my $bq = $quiet ? "2>$DEVNULL" : "";
    run_cmd("bedtools getfasta -s -fo \Q$outseq\E -fi $FASTA -bed $BED $bq");
  } 
}
#----------------------------------------------------------------------
sub run_aragorn {
  my($fasta, $code) = @_;
  my $outfile = "$fasta.aragorn.out";
  my $cmd = "aragorn -w -gc$code -o '$outfile' '$fasta'";
  run_cmd($cmd);
  return $outfile;
}
#----------------------------------------------------------------------
sub parse_aragorn {
  my($fname) = @_;
  my @gff;
  #>AL123456
  #54 genes found
  #1   tRNA-Ile    [10887,10961]   35     (gat)
  #2   tRNA-Ala    [11112,11185]   34     (tgc)
  #3   tRNA-Leu    [25644,25728]   34     (cag
  #4   tRNA-Ser   c[243100,243188] 35     (gga)
  #46  tmRNA       [753615,753977] 90,125 ANDENYALAA**
  open my $fh, '<', $fname;
  my $seqid;
  while (<$fh>) {
    chomp;
    if (m/^>(\S+)/) {
      $seqid = $1;
    }
    elsif (m/found/) {
      msg("aragorn: $_");
    }
    else {
      my @x = split ' ', $_;
      $x[2] =~ m/(c?)\[(\d+),(\d+)\]/;
      my($begin,$end) = ($2,$3);
      my $strand = $1 ? '-' : '+';
      my $type = $x[1]; 
      $type =~ s/-.*$//;
      $x[3] =~ m/(^\d+)/;
      my $score = $1 // $DOT;
      push @gff, [
        $seqid,
        "$EXE:$VERSION",
        $type, 
        $begin, $end, 
        $score, 
        $strand, 
        $DOT,
        "Name=$x[1];note=$x[4]"
      ];
    }
  }
  return @gff;
}
#----------------------------------------------------------------------
sub run_infernal {
  my($tool, $fasta, $king, $feat) = @_;
  my $outfile = "$fasta.$king.$feat.tbl";
  # --cut_ga is recommended for Rfam but --rfam probaly does this?
  my $speed = $fast ? "--hmmonly" : "--rfam -g";
  my $cmd = "$tool $speed";
  $cmd .= " --cpu $threads -E $evalue";
  $cmd .= " --noali --acc";
  $cmd .= " --tblout $outfile";
  $cmd .= " -o $DEVNULL";
  # the 2 positional parametrs
  $cmd .= " $DBDIR/$king/$king.$feat.cm";
  $cmd .= " $fasta";
  run_cmd($cmd);
  return $outfile;
}
#----------------------------------------------------------------------
sub parse_infernal {
  my($fname, $ftype) = @_;
  my $dpos = -1;
  my @gff;
  open my $fh, '<', $fname;
  while (<$fh>) {
    chomp;
    if (m/#target/) {
      # we are in the header
      dbg($_);
      $dpos = index($_, "description");
      $dpos > 0 or err("Bad header: $_");
    }
    next if m/^#/;    # comment line
    next if m/^\s*$/; # empty line
    
    my $prod = substr($_, $dpos);
    my @x = split ' ', $_;
    dbg(Dumper(\@x));

    $x[9] =~ m/^[+-]$/ or err("Bad hit line: @x");
    my($begin,$end,$strand) = $x[7] < $x[8] 
                            ? ($x[7],$x[8],'+') 
                            : ($x[8],$x[7],'-');
    my($seqid, $acc, $gene) = ($x[0], $x[3], $x[2]);
    my $score = defined $x[14]  ? $x[14] : $DOT;
    my $len = $end-$begin+1;

    msg("Found:", $gene, $seqid, "L=$len", "$begin..$end", $strand, $prod);

    push @gff, [
      $seqid, 
      "$EXE:$VERSION", 
      $ftype,
      $begin, $end, $score, $strand,$DOT, 
        "Name=$gene"
       .";db_xref=Rfam:$acc"
    ];
  }
  return @gff;
}
#----------------------------------------------------------------------
sub run_cmd {
  my($cmd) = @_;
  msg("Running: $cmd");
  system($cmd)==0 or err("COuld not run: $cmd");
}
#----------------------------------------------------------------------
sub enumerate_dbs {
  my($dir) = @_;
  my $db = {};
  for my $cm (glob("$dir/*/*.cm")) {
    #msg("* $cm");
    $cm =~ m=(\w+)\.(\w+)\.cm$= or err("Bad mode; $cm");
    $db->{$1}{$2} = $cm;
  }
  return $db;
}

sub list_dbs {
  my $dbs = enumerate_dbs($DBDIR);
  #print Dumper($dbs);
  msg("Database home: $DBDIR");
  msg("Kingdoms:",sort keys %$dbs);
  exit(0);
}
#----------------------------------------------------------------------
sub setup_dbs {
  msg("Make indicesin $DBDIR");
  run_cmd("find '$DBDIR' -name '*.cm' -exec cmpress -F {} \\;");
  msg("Indexed databases.");
  exit(0);
}
#----------------------------------------------------------------------
sub require_exe {
  for my $exe (@_) {
    my($which) = qx"which $exe 2>$DEVNULL";
    $which or err("Can not find required '$exe' in PATH");
    chomp $which;
    msg("Found $exe - $which");
  }
}
#----------------------------------------------------------------------
sub msg {
  return if $quiet;
  my $line = "[$EXE] @_\n";
  print STDERR $line;
}
#----------------------------------------------------------------------
sub dbg {
  print STDERR "[$EXE] DEBUG:\n", @_,"\n" if $debug;
}
#----------------------------------------------------------------------
sub err {
  $quiet=0;
  msg("ERROR:", @_);
  exit(2);
}
#----------------------------------------------------------------------
sub version {
  print "$EXE $VERSION\n";
  exit;
}
#----------------------------------------------------------------------
sub show_citation {
  print STDERR << "EOCITE";
  
If you use Barrnap in your work, please cite:

    Seemann T
    $EXE $VERSION : $DESC
    $URL
    
Thank you.

EOCITE

  exit;
}
#----------------------------------------------------------------------
#----------------------------------------------------------------------
# Option setting routines

sub setOptions {
  use Getopt::Long;

  @Options = (
    'GENERAL',
    {OPT=>"help",    VAR=>\&usage,             DESC=>"This help"},
    {OPT=>"version", VAR=>\&version,           DESC=>"Print version and exit"},
    {OPT=>"citation",VAR=>\&show_citation,     DESC=>"Print citation for referencing $EXE"},
    {OPT=>"quiet!",  VAR=>\$quiet, DESC=>"No screen output"},
    {OPT=>"debug!",  VAR=>\$debug, DESC=>"Debug mode"},
    'DATABASE',
    {OPT=>"listdb",VAR=>\&list_dbs, DESC=>"Descube installed database"},
    {OPT=>"setupdb",VAR=>\&setup_dbs, DESC=>"Setup install databases"},
    {OPT=>"kingdom=s", VAR=>\$kingdom, DEFAULT=>'bac', DESC=>"Kingdom: ".join(',', keys %KINGDOM) },
    "MODE",
    {OPT=>"rrna!",  VAR=>\$rrna,  DEFAULT=>1, DESC=>"Scan for rRNA, disable with -no-rrna" },
    {OPT=>"trna!",  VAR=>\$trna,  DEFAULT=>0, DESC=>"Scan for tRNA/tmRNA" },
    {OPT=>"ncrna!", VAR=>\$ncrna, DEFAULT=>0, DESC=>"Scan for ncRNA" },
    {OPT=>"operon!", VAR=>\$operon, DEFAULT=>0, DESC=>"Idenitfy RNA opersons" },
    {OPT=>"opdist=i", VAR=>\$opdist, DEFAULT=>200,  DESC=>"Operon clustering threshold" },
    "SPEED",
    {OPT=>"threads=i", VAR=>\$threads, DEFAULT=>1,  DESC=>"CPU cores to use"},
    {OPT=>"fast!", VAR=>\$fast, DEFAULT=>undef,  DESC=>"Trade speed for accuracy"},
    "OUTPUT",
    {OPT=>"lencutoff=f",VAR=>\$lencutoff, DEFAULT=>0.8, DESC=>"Proportional length threshold to label as partial"},
    {OPT=>"reject=f",VAR=>\$reject, DEFAULT=>0.25, DESC=>"Proportional length threshold to reject prediction"},
    {OPT=>"evalue=f",VAR=>\$evalue, DEFAULT=>0.001, DESC=>"Similarity e-value cut-off"},
    {OPT=>"incseq!",  VAR=>\$incseq,  DESC=>"Include FASTA input in GFF3 output"},
    {OPT=>"incseqreg!",  VAR=>\$incseqreg,  DESC=>"Include #sequence-region in GFF3 header"},
    {OPT=>"outseq=s",  VAR=>\$outseq,  DESC=>"Save RNA hits to FASTA file"},
  );

#  (!@ARGV) && (usage(1));

  &GetOptions(map {$_->{OPT}, $_->{VAR}} grep { ref } @Options) || usage(1);

  # Now setup default values.
  foreach (@Options) {
    if (ref $_ && defined($_->{DEFAULT}) && !defined(${$_->{VAR}})) {
      ${$_->{VAR}} = $_->{DEFAULT};
    }
  }
}

#----------------------------------------------------------------------
sub usage {
  my($exitcode) = @_;
  $exitcode = 0 if $exitcode eq 'help'; # what gets passed by getopt func ref
  $exitcode ||= 0;
  select STDERR if $exitcode; # write to STDERR if exitcode is error

  print "NAME\n";
  print "  $EXE $VERSION\n";
  print "SYNOPSIS\n";
  print "  $DESC\n";
  print "USAGE\n";
  print "  $EXE [opts] seq.{fa,gbk,fq}[.gz] ... \n";
  foreach (@Options) {
    if (ref $_) {
      my $def = defined $_->{DEFAULT} ? "[$_->{DEFAULT}]" : "";
      my $opt = $_->{OPT};
      if ($opt =~ s/!$//) {
        $def = $_->{DEFAULT} ? "[on]" : "";
      }
      $opt =~ s/=s$/ STR/;
      $opt =~ s/=i$/ INT/;
      $opt =~ s/=f$/ NUM/;
      printf "  --%-13s %s %s\n", $opt, $_->{DESC}, $def;
    }
    else {
      print "$_\n";
    }
  }
  print "HOMEPAGE\n";
  print "  $URL";
  exit($exitcode);
}

#---------------------------------------------------------------------
