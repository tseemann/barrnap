#!/usr/bin/env perl
use 5.32.0;
use strict;
use warnings;
use Cwd qw"fast_abs_path";
use List::Util qw"min max";
use List::MoreUtils qw"uniq";
use FindBin;
use File::Temp qw"tempdir";
use File::Basename;
use File::Spec;
use Data::Dumper;

# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
# global variables

my $VERSION = "1.0.2";
my $EXE = $FindBin::RealScript;
my $DESC = "rapid ribosomal RNA prediction";
my $AUTHOR = 'Torsten Seemann';
my $URL = 'https://github.com/tseemann/barrnap';
my $DBDIR = fast_abs_path("$FindBin::RealBin/../db");
my $DEVNULL = File::Spec->devnull;

my $dbs = enumerate_dbs($DBDIR);

my %KINGDOM = (map { $_ => 1 } 
  sort keys %$dbs );

my %TYPE = (map { $_ => 1 } 
  qw"rRNA tRNA" ); # ncRNA coming soon

# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
# command line options

my(@Options, $quiet, $kingdom, $threads, 
  $types, $listdb, $setupdb, $fast, $debug,
  $evalue, $lencutoff, $reject, $incseq, $outseq);
setOptions();

# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
# check all is well

@ARGV or err("No input sequence files provided");

msg("This is $EXE $VERSION by $AUTHOR");
msg("Obtained from $URL");

msg("Checking dependencies:");
require_exe('cmsearch', 'bedtools', 'aragorn', 'any2fasta');

$threads > 0 or err("Invalid --threads $threads");
$evalue > 0 or err("Invalid --evalue $evalue");
$lencutoff > 0 or err("Invalid --lencutoff $lencutoff");
$reject > 0 or err("Invalid --reject cutoff $reject");

exists $KINGDOM{$kingdom} or
  err("Imvalid --kingdom '$kingdom'. Try:", values(%KINGDOM) );
# FIXME: store with --kingdom database  
my $code = $kingdom =~ m/^(bac|arc)$/ ? 11 : 1;

my @type = split m/\W+/, $types;
for my $t (@type) {
  exists $TYPE{$t} or err("Invalid --type $t");
}

# Check all input files and make
my @infile;
for my $infile (uniq @ARGV) {
  $infile = '/dev/stdin' if $infile eq '-';
  -r $infile or err("Can't read file: $infile");
  push @infile, quotemeta File::Spec->rel2abs($infile);
}
@infile or err("No input files provided.");
dbg( Dumper(\@infile) );

# Make a temp folder for all intermediate files
my $tempdir = $debug ? '.' : tempdir(CLEANUP=>1);
chdir($tempdir);

# Write a single combined FASTA file
my $FASTA = "$EXE.fasta";
my($a2f_opt,$sk_opt) = $quiet ? ('-q','--quiet') : ('','');
run_cmd("any2fasta -k $a2f_opt @infile > $FASTA.tmp");
run_cmd("seqkit seq $sk_opt -g --min-len 1 -u -w 60 $FASTA.tmp > $FASTA");
-s $FASTA or err("No sequences found in input");

# Loop over the RNA types chosen to scan
my @gff;
for my $type (@type) {
  if ($type eq 'tRNA') {
    my $ara_file = run_aragorn($FASTA,$code,$type);
    push @gff, parse_aragorn($ara_file);
  }
  else {
    my $tbl_file = run_infernal("cmsearch", $FASTA, $kingdom, $type);
    push @gff,parse_infernal($tbl_file, $type);
  }
}

msg("Found", 0+@gff, "@type features.");

write_gff(\*STDOUT, \@gff);

msg("Done.");

#----------------------------------------------------------------------
sub write_bed {
  my($fh, $gff) = @_;
  # $gff =  arrayref of gff arrays
  foreach (@$gff) {
  # https://en.wikipedia.org/wiki/General_feature_format#GFF_general_structure
  # https://en.wikipedia.org/wiki/BED_(file_format)#Format
    print {$fh} tsv(
      $_->[0],   # chr
      $_->[3]-1, # begin 0-based
      $_->[4],   # end (exclusive)
      '.'   ,    # name
      1000,      # socre 1-1000
      $_->[6],   # strand
    );
  }
}

#----------------------------------------------------------------------
sub tsv {
  return join("\t",@_)."\n";
}
#----------------------------------------------------------------------
sub gff_sort {
  # sort by seqid, then start pos
  return ($a->[0] cmp $b->[0]) || ($a->[3] <=> $b->[3]);
}
#----------------------------------------------------------------------
sub write_gff {
  my($fh, $feats) = @_;
  select $fh;
  print "##gff-version 3\n";
  for my $row (sort { &gff_sort } @$feats) {
     print tsv(@$row);
  }
  if ($incseq) {
    print "##FASTA\n";
    run_cmd("cat $FASTA");
  }
  if ($outseq) {
#   msg("Writing hit sequences to: $outseq");
    my $BED = "$EXE.bed";
    open my $bed, '>', $BED;
    write_bed($bed, \@gff);
    close $bed;
    run_cmd("seqkit faidx $sk_opt $FASTA");
    my $bq = $quiet ? "2>$DEVNULL" : "";
    run_cmd("bedtools getfasta -s -fo \Q$outseq\E -fi $FASTA -bed $BED $bq");
  } 
}
#----------------------------------------------------------------------
sub run_aragorn {
  my($fasta, $code, $type) = @_;
  my $outfile = "$fasta.$type.out";
  my $cmd = "aragorn -w -gc$code -o '$outfile' '$fasta'";
  run_cmd($cmd);
  return $outfile;
}
#----------------------------------------------------------------------
sub parse_aragorn {
  my($fname) = @_;
  my @gff;
  #>AL123456
  #54 genes found
  #1   tRNA-Ile    [10887,10961] 35   (gat)
  #2   tRNA-Ala    [11112,11185] 34   (tgc)
  #3   tRNA-Leu    [25644,25728] 34   (cag
  #4   tRNA-Ser   c[243100,243188] 35 (gga)
  open my $fh, '<', $fname;
  my $seqid;
  while (<$fh>) {
    chomp;
    if (m/^>(\S+)/) {
      $seqid = $1;
    }
    elsif (m/found/) {
      msg("aragorn: $_");
    }
    else {
      my @x = split ' ', $_;
      $x[2] =~ m/(c?)\[(\d+),(\d+)\]/;
      my($begin,$end) = ($2,$3);
      my $strand = $1 ? '-' : '+';
      my $type = $x[1]; 
      $type =~ s/-.*$//;
      push @gff, [
        $seqid,
        "$EXE:$VERSION",
        $type, 
        $begin, $end, 
        $x[3], 
        $strand, 
        '.',
        "Name=$x[1];note=$x[4]"
      ];
    }
  }
  return @gff;
}
#----------------------------------------------------------------------
sub run_infernal {
  my($tool, $fasta, $king, $feat) = @_;
  my $outfile = "$fasta.$king.$feat.tbl";
  # --cut_ga is recommended for Rfam but --rfam probaly does this?
  my $speed = $fast ? "--hmmonly" : "--rfam -g";
  my $cmd = "$tool $speed";
  $cmd .= " --cpu $threads -E $evalue";
  $cmd .= " --noali --acc";
  $cmd .= " --tblout $outfile";
  $cmd .= " -o $DEVNULL";
  # the 2 positional parametrs
  $cmd .= " $DBDIR/$king/$king.$feat.cm";
  $cmd .= " $fasta";
  run_cmd($cmd);
  return $outfile;
}
#----------------------------------------------------------------------
sub parse_infernal {
  my($fname, $ftype) = @_;
  my $dpos = -1;
  my @gff;
  open my $fh, '<', $fname;
  while (<$fh>) {
    chomp;
    if (m/#target/) {
      # we are in the header
      dbg($_);
      $dpos = index($_, "description");
      $dpos > 0 or err("Bad header: $_");
    }
    next if m/^#/;    # comment line
    next if m/^\s*$/; # empty line
    
    my $prod = substr($_, $dpos);
    my @x = split ' ', $_;
    #for my $i (0 .. $#x) {
    #  print "[$i] $x[$i]\n";
    #} 
    $x[9] =~ m/^[+-]$/ or err("Bad hit line: @x");
    my($begin,$end,$strand) = $x[7] < $x[8] 
                            ? ($x[7],$x[8],'+') 
                            : ($x[8],$x[7],'-');
    my($seqid, $acc, $gene) = ($x[0], $x[1], $x[2]);
    my $score = defined $x[14]  ? $x[14] : '.';
    my $len = $end-$begin+1;

    msg("Found:", $gene, $seqid, "L=$len", "$begin..$end", $strand, $prod);

    push @gff, [
      $seqid, 
      "$EXE:$VERSION", 
      $ftype,
      $begin, $end, $score, $strand,'.', 
        "Name=$gene"
       .";db_xref=Rfam:$acc"
       .";product=$prod"
    ];
  }
  return @gff;
}

#----------------------------------------------------------------------
sub run_cmd {
  my($cmd) = @_;
  msg("Running: $cmd");
  system($cmd)==0 or err("COuld not run: $cmd");
}
#----------------------------------------------------------------------
sub enumerate_dbs {
  my($dir) = @_;
  my $db = {};
  for my $cm (glob("$dir/*/*.cm")) {
    #msg("* $cm");
    $cm =~ m=(\w+)\.(\w+)\.cm$= or err("Bad mode; $cm");
    $db->{$1}{$2} = $cm;
  }
  return $db;
}
#----------------------------------------------------------------------
sub list_dbs {
  my $dbs = enumerate_dbs($DBDIR);
  #print Dumper($dbs);
  msg("Database home: $DBDIR");
  msg("Kingdoms:",sort keys %$dbs);
  exit(0);
}
#----------------------------------------------------------------------
sub setup_dbs {
  msg("Make indicesin $DBDIR");
  run_cmd("find '$DBDIR' -name '*.cm' -exec cmpress -F {} \\;");
  msg("Indexed databases.");
  exit(0);
}
#----------------------------------------------------------------------
sub require_exe {
  for my $exe (@_) {
    my($which) = qx"which $exe 2>$DEVNULL";
    $which or err("Can not find required '$exe' in PATH");
    chomp $which;
    msg("Found $exe - $which");
  }
}
#----------------------------------------------------------------------
sub msg {
  return if $quiet;
  my $line = "[$EXE] @_\n";
  print STDERR $line;
}
#----------------------------------------------------------------------
sub dbg {
  print STDERR "[$EXE] DEBUG:\n", @_,"\n" if $debug;
}
#----------------------------------------------------------------------
sub err {
  $quiet=0;
  msg("ERROR:", @_);
  exit(2);
}
#----------------------------------------------------------------------
sub version {
  print "$EXE $VERSION\n";
  exit;
}
#----------------------------------------------------------------------
sub show_citation {
  print STDERR << "EOCITE";
  
If you use Barrnap in your work, please cite:

    Seemann T
    $EXE $VERSION : $DESC
    $URL
    
Thank you.

EOCITE

  exit;
}
#----------------------------------------------------------------------
# Option setting routines

sub setOptions {
  use Getopt::Long;

  @Options = (
    'GENERAL',
    {OPT=>"help",    VAR=>\&usage,             DESC=>"This help"},
    {OPT=>"version", VAR=>\&version,           DESC=>"Print version and exit"},
    {OPT=>"citation",VAR=>\&show_citation,     DESC=>"Print citation for referencing $EXE"},
    {OPT=>"quiet!",  VAR=>\$quiet, DEFAULT=>0, DESC=>"No screen output"},
    {OPT=>"debug!",  VAR=>\$debug, DEFAULT=>0, DESC=>"Debug mode"},
    'DATABASE',
    {OPT=>"listdb",VAR=>\&list_dbs, DESC=>"Descube installed database"},
    {OPT=>"setupdb",VAR=>\&setup_dbs, DESC=>"Setup install databases"},
    {OPT=>"kingdom=s", VAR=>\$kingdom, DEFAULT=>'bac', DESC=>"Kingdom: ".join(' ', values %KINGDOM) },
    {OPT=>"types=s", VAR=>\$types,  DEFAULT=>'rRNA', DESC=>"Features: ".join(' ', keys %TYPE) },
    "SPEED",
    {OPT=>"threads=i",  VAR=>\$threads, DEFAULT=>1,  DESC=>"Number of threads/cores/CPUs to use"},
    {OPT=>"fast!",  VAR=>\$fast, DEFAULT=>undef,  DESC=>"Trade speed for accuracy"},
    "OUTPUT",
    {OPT=>"lencutoff=f",VAR=>\$lencutoff, DEFAULT=>0.8, DESC=>"Proportional length threshold to label as partial"},
    {OPT=>"reject=f",VAR=>\$reject, DEFAULT=>0.25, DESC=>"Proportional length threshold to reject prediction"},
    {OPT=>"evalue=f",VAR=>\$evalue, DEFAULT=>"0.001", DESC=>"Similarity e-value cut-off"},
    {OPT=>"incseq!",  VAR=>\$incseq, DEFAULT=>0, DESC=>"Include FASTA _input_ sequences in GFF3 output"},
    {OPT=>"outseq=s",  VAR=>\$outseq, DEFAULT=>'', DESC=>"Save rRNA hit seqs to this FASTA file"},
  );

#  (!@ARGV) && (usage(1));

  &GetOptions(map {$_->{OPT}, $_->{VAR}} grep { ref } @Options) || usage(1);

  # Now setup default values.
  foreach (@Options) {
    if (ref $_ && defined($_->{DEFAULT}) && !defined(${$_->{VAR}})) {
      ${$_->{VAR}} = $_->{DEFAULT};
    }
  }
}

#----------------------------------------------------------------------
sub usage {
  my($exitcode) = @_;
  $exitcode = 0 if $exitcode eq 'help'; # what gets passed by getopt func ref
  $exitcode ||= 0;
  select STDERR if $exitcode; # write to STDERR if exitcode is error

  print "NAME\n";
  print "  $EXE $VERSION\n";
  print "SYNOPSIS\n";
  print "  $DESC\n";
  print "USAGE\n";
  print "  $EXE [opts] seq.{fa,gbk,fq}[.gz] ... \n";
  foreach (@Options) {
    if (ref) {
      my $def = defined($_->{DEFAULT}) ? " (default '$_->{DEFAULT}')" : "";
      $def = ($def ? ' (default OFF)' : '(default ON)') if $_->{OPT} =~ m/!$/;
      my $opt = $_->{OPT};
      $opt =~ s/!$//; 
      $opt =~ s/=s$/ [X]/; 
      $opt =~ s/=i$/ [N]/;
      $opt =~ s/=f$/ [n.n]/;
      printf "  --%-15s %s%s\n", $opt, $_->{DESC}, $def;
    }
    else {
      print "$_\n";
    }      
  }
  print "HOMEPAGE\n";
  print "  $URL";
  exit($exitcode);
}

#---------------------------------------------------------------------
