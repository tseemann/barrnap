#!/usr/bin/env perl
use 5.32.0;
use strict;
use warnings;
use Cwd qw"fast_abs_path";
use List::Util qw"min max";
use List::MoreUtils qw"uniq minmax";
use FindBin;
use File::Temp qw"tempdir";
use File::Basename;
use File::Spec;
use Data::Dumper;

# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
# global variables

my $VERSION = "1.3.1";
my $EXE = $FindBin::RealScript;
my $DESC = "Rapid micrboial rRNA/tRNA/ncRNA prediction";
my $AUTHOR = 'Torsten Seemann';
my $URL = 'https://github.com/tseemann/barrnap';
my $DBDIR = fast_abs_path("$FindBin::RealBin/../db");
my $DEVNULL = File::Spec->devnull;
my $DOT = '.';

my $dbs = enumerate_dbs($DBDIR);
my %KINGDOM = (map { $_ => 1 } sort keys %$dbs );

# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
# command line options

my(@Options, $quiet, $kingdom, $threads, 
  $listdb, $updatedb, $fast, $debug, 
  $operon, $opdist, $addids,
  $evalue, $lencutoff, $reject, $incseq, 
  $incseqreg, $outseq, $trna, $rrna, $ncrna);
setOptions();

# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
# check all is well

@ARGV or err("No input sequence files provided");

msg("This is $EXE $VERSION by $AUTHOR");
msg("Obtained from $URL");

msg("Checking dependencies:");
require_exe('cmsearch', 'bedtools', 'aragorn', 'any2fasta', 'make');

$trna || $rrna || $ncrna or err("Must choose at least one of --rrna --trna --ncrna");
$threads > 0 or err("Invalid --threads $threads");
$evalue > 0 or err("Invalid --evalue $evalue");
$lencutoff > 0 or err("Invalid --lencutoff $lencutoff");
$reject > 0 or err("Invalid --reject cutoff $reject");

exists $KINGDOM{$kingdom} or
  err("Imvalid --kingdom '$kingdom'. Try:", values(%KINGDOM) );
# FIXME: store with --kingdom database  
my $code = $kingdom =~ m/^(bac|arc)$/ ? 11 : 1;

# Check all input files and make
my @infile;
for my $infile (uniq @ARGV) {
  $infile = '/dev/stdin' if $infile eq '-';
  -r $infile or err("Can't read file: $infile");
  push @infile, quotemeta File::Spec->rel2abs($infile);
}
@infile or err("No input files provided.");
dbg( Dumper(\@infile) );

# Make a temp folder for all intermediate files
my $tempdir = $debug ? $DOT : tempdir(CLEANUP=>1);
chdir($tempdir);

# Write a single combined FASTA file
my $FASTA = "$EXE.fasta";
my($a2f_opt,$sk_opt) = $quiet ? ('-q','--quiet') : ('','');
run_cmd("any2fasta -k $a2f_opt @infile > $FASTA.tmp");
run_cmd("seqkit seq $sk_opt -g --min-len 1 -u -w 60 $FASTA.tmp > $FASTA");
-s $FASTA or err("No sequences found in input");
run_cmd("rm -f $FASTA.fai"); # for --debug case of tmp=.
run_cmd("seqkit faidx $sk_opt $FASTA");

# Loop over the RNA types chosen to scan
my @gff;
if ($trna) {
  my $ara_file = run_aragorn($FASTA, $code);
  push @gff, parse_aragorn($ara_file);
}
if ($rrna) {
  my $tool = 'cmsearch';
  my $tbl_file = run_infernal($tool, $FASTA, $kingdom, 'rRNA');
  push @gff, parse_infernal($tool, $tbl_file, 'rRNA');;
}
if ($operon) {
  @gff = sort_gff(\@gff); # for bedtools
  push @gff, find_operons(\@gff);
}
if ($ncrna) {
  my $tool = 'cmscan';
  my $tbl_file = run_infernal($tool, $FASTA, $kingdom, 'ncRNA');
  push @gff,parse_infernal($tool, $tbl_file, 'ncRNA');
}
msg("Found", 0+@gff, "features.");

@gff = sort_gff(\@gff);
gff_add_ids(\@gff) if $addids;
print_gff(\*STDOUT, \@gff, $incseq);

msg("Done.");

#----------------------------------------------------------------------
sub gff_add_ids {
  my($feats) = @_;
  my %count;
  for my $f (@$feats) {
    my $nv = $f->[-1]; # tagsin last column
    my $t = $nv =~ m/Name=([^;]+)/ ? $1 : $f->[2];
    $t =~ s/\s/_/g;
    $count{$t}++; 
    $f->[-1] = join ';', "ID=$t-$count{$t}", $nv;
  }
}
#----------------------------------------------------------------------
sub find_operons {
  my($feats) = @_;
  my @operons;
  my $outf = "$EXE.gff";
  open my $fh, '>', $outf;
  print_gff($fh, $feats, 0);
  my $inf = "$EXE.operon.bed";
  run_cmd("bedtools merge -s -d $opdist -i $outf" 
         ." -c 3 -o count,collapse -delim '-'"
         ." > $inf");
  open my $BED, '<', $inf;
  while (<$BED>) {
    chomp;
    my @bed = split m/\t/;
    next unless $bed[3] > 1; # not singletons
    my $name = $bed[4] =~ /rRNA/ ? 'rRNA' : 'tRNA';
    my($b,$e,$s) = bed2gff_coords($bed[1],$bed[2]);
    push @operons, [
      $bed[0],
      "$EXE:$VERSION",
      'operon',
      $b,
      $e,
      $DOT,
      $s,
      $DOT,
      "Name=$name operon;product=$name operon: $bed[4]"
    ];
  }
  return @operons;
}
#----------------------------------------------------------------------
sub write_bed {
  my($fh, $gff) = @_;
  # $gff =  arrayref of gff arrays
  foreach (@$gff) {
  # https://en.wikipedia.org/wiki/General_feature_format#GFF_general_structure
  # https://en.wikipedia.org/wiki/BED_(file_format)#Format
    print {$fh} tsv(
      $_->[0],   # chr
      $_->[3]-1, # begin 0-based
      $_->[4],   # end (exclusive)
      $DOT,      # name
      1000,      # socre 1-1000
      $_->[6],   # strand
    );
  }
}
#----------------------------------------------------------------------
sub bed2gff_coords {
  my($begin,$end) = @_;
  return (
    min($begin,$end) + 1,
    max($begin,$end),
    $begin > $end ? '-' : '+',
  )
}
#----------------------------------------------------------------------
sub gff2bed_coords {
  my($start,$finish,$strand) = @_;
  return $strand eq '+' 
         ? ($start-1,$finish)
         : ($finish-1,$start);
}
#----------------------------------------------------------------------
sub tsv {
  return join("\t",@_)."\n";
}
#----------------------------------------------------------------------
sub gff_cmp {
  return ($a->[0] cmp $b->[0])   # name
      || ($a->[3] <=> $b->[3])   # start
      || ($b->[4] <=> $a->[4]) ; # end (rev)
}
#----------------------------------------------------------------------
sub sort_gff {
  my($gff) = @_;
  return sort { &gff_cmp } @$gff; 
}
#----------------------------------------------------------------------
sub print_gff {
  my($fh, $feats, $add_seq) = @_;
  select $fh;
  print "##gff-version 3\n";
  if ($incseqreg) {
    run_cmd(
       "seqkit fx2tab --only-id --name --length $FASTA"
     ." | sed 's/\\t/ 1 /'"
     ." | sed 's/^/##sequence-region /'"
    );
  }
  # print each feature line (assymeed sorted)
  for my $row (@$feats) {
     print tsv(@$row);
  }
  if ($add_seq) {
    print "##FASTA\n";
    run_cmd("cat $FASTA");
  }
  if ($outseq) {
#   msg("Writing hit sequences to: $outseq");
    my $BED = "$EXE.bed";
    open my $bed, '>', $BED;
    write_bed($bed, \@gff);
    close $bed;
    my $bq = $quiet ? "2>$DEVNULL" : "";
    run_cmd("bedtools getfasta -s -fo \Q$outseq\E -fi $FASTA -bed $BED $bq");
  } 
}
#----------------------------------------------------------------------
sub run_aragorn {
  my($fasta, $code) = @_;
  my $outfile = "$fasta.aragorn.out";
  my $cmd = "aragorn -w -gc$code -o '$outfile' '$fasta'";
  run_cmd($cmd);
  return $outfile;
}
#----------------------------------------------------------------------
sub parse_aragorn {
  my($fname) = @_;
  my @gff;
  #>AL123456
  #54 genes found
  #1   tRNA-Ile    [10887,10961]   35     (gat)
  #2   tRNA-Ala    [11112,11185]   34     (tgc)
  #3   tRNA-Leu    [25644,25728]   34     (cag
  #4   tRNA-Ser   c[243100,243188] 35     (gga)
  #46  tmRNA       [753615,753977] 90,125 ANDENYALAA**
  open my $fh, '<', $fname;
  my $seqid;
  while (<$fh>) {
    chomp;
    if (m/^>(\S+)/) {
      $seqid = $1;
    }
    elsif (m/found/) {
      msg("aragorn: $_");
    }
    else {
      my @x = split ' ', $_;
      $x[2] =~ m/(c?)\[(\d+),(\d+)\]/;
      my($begin,$end) = ($2,$3);
      my $strand = $1 ? '-' : '+';
      my $type = $x[1]; 
      $type =~ s/-.*$//;
      #$x[3] =~ m/(^\d+)/;
      #my $score = $1 // $DOT; 
      my $score = $DOT;
      push @gff, [
        $seqid,
        "$EXE:$VERSION",
        $type, 
        $begin, $end, 
        $score, 
        $strand, 
        $DOT,
        "Name=$x[1];product=transfer RNA $x[1] $x[4]"
      ];
    }
  }
  return @gff;
}
#----------------------------------------------------------------------
sub run_infernal {
  my($tool, $fasta, $king, $feat) = @_;
  my $outfile = "$fasta.$king.$feat.tbl";
  # --cut_ga is recommended for Rfam but --rfam probaly does this?
  my $speed = $fast ? "--hmmonly" : "--rfam -g";
  my $cmd = "$tool $speed";
  $cmd .= " --cpu $threads -E $evalue";
  $cmd .= " --tblout $outfile";
  $cmd .= " --noali -o $DEVNULL";
  # the 2 positional parametrs
  $cmd .= " $DBDIR/$king/$king.$feat.cm";
  $cmd .= " $fasta";
  run_cmd($cmd);
  return $outfile;
}
#----------------------------------------------------------------------
sub parse_infernal {
  my($tool, $fname, $ftype) = @_;
  my $dpos = -1;
  my @gff;
  open my $fh, '<', $fname;
  while (<$fh>) {
    chomp;
    next if m/^#/;    # comment line
    next if m/^\s*$/; # empty line
    
    my @x = split ' ', $_;
    dbg( map { "[$_]='$x[$_]' " } 0 .. $#x );

    my $strand = $x[9];
    $strand =~ m/^[+-]$/ or err("Bad hit line: @x");
    my($begin,$end) = minmax($x[7], $x[8]);
    my $prod = join( ' ', @x[17..$#x] );
    my $score = $x[15] // $DOT;

    # label = $seqid  $seqaccd $model   $mode;_acc
    # rRMA  = E.coli  -        5S_rRNA  RF00001
    # mcRMA = AsrC    RF02746  E.coli   -
    if ($tool eq 'cmscan') {
      my @pair = splice @x, 2, 2;
      unshift @x, @pair;
    }
    else {
      $x[2] =~ m/^([^_]+)/;
      $prod = "$1 ribosomal RNA";
    }
    my($seq_id, $model_id, $model_acc) = ($x[0], $x[2], $x[3]);

    msg("Found $ftype $model_id($model_acc) @ $seq_id:$begin-$end($strand)"); 

    push @gff, [
      $seq_id, 
      "$EXE:$VERSION", 
      $ftype,
      $begin, $end, $score, $strand,$DOT, 
        "Name=$model_id"
       .";Dbxref=Rfam:$model_acc"
       .";product=$prod"
    ];
  }
  return @gff;
}
#----------------------------------------------------------------------
sub run_cmd {
  my($cmd) = @_;
  msg("Running: $cmd");
  system($cmd)==0 or err("COuld not run: $cmd");
}
#----------------------------------------------------------------------
sub enumerate_dbs {
  my($dir) = @_;
  my $db = {};
  for my $cm (glob("$dir/*/*.cm")) {
    #msg("* $cm");
    $cm =~ m=(\w+)\.(\w+)\.cm$= or err("Bad mode; $cm");
    $db->{$1}{$2} = $cm;
  }
  return $db;
}
#----------------------------------------------------------------------
sub list_dbs {
  my $dbs = enumerate_dbs($DBDIR);
  #print Dumper($dbs);
  msg("Database home: $DBDIR");
  my $count=0;
  for my $k (sort keys %$dbs) {
    msg("--kingdom '$k' has: tRNA",sort keys %{$dbs->{$k}});;
    $count++;
  }
  $count or err("You have no databases installed!"
   ."\nRun '$EXE --updatedb' to update/repair thos");
  exit(0);
}
#----------------------------------------------------------------------
sub update_dbs {
  -d $DBDIR or err("Database folder: $DBDIR does not exist");
  -w $DBDIR or err("You don't have permissions to modify the database folder: $DBDIR");my $make = "make -C \Q$DBDIR/../build\E";
  run_cmd("$make bigclean");
  run_cmd("$make install");  
  list_dbs();
  exit(0);
}
#----------------------------------------------------------------------
sub require_exe {
  for my $exe (@_) {
    my($which) = qx"which $exe 2>$DEVNULL";
    $which or err("Can not find required '$exe' in PATH");
    chomp $which;
    msg("Found $exe - $which");
  }
}
#----------------------------------------------------------------------
sub msg {
  return if $quiet;
  my $line = "[$EXE] @_\n";
  print STDERR $line;
}
#----------------------------------------------------------------------
sub dbg {
  print STDERR "[$EXE] DEBUG:\n", @_,"\n" if $debug;
}
#----------------------------------------------------------------------
sub err {
  $quiet=0;
  msg("ERROR:", @_);
  exit(2);
}
#----------------------------------------------------------------------
sub version {
  print "$EXE $VERSION\n";
  exit;
}
#----------------------------------------------------------------------
sub show_citation {
  print STDERR << "EOCITE";
  
If you use Barrnap in your work, please cite:

    Seemann T
    $EXE $VERSION : $DESC
    $URL
    
Thank you.

EOCITE

  exit;
}
#----------------------------------------------------------------------
# Option setting routines

sub setOptions {
  use Getopt::Long;

  @Options = (
    'GENERAL',
    {OPT=>"help",    VAR=>\&usage,             DESC=>"This help"},
    {OPT=>"version", VAR=>\&version,           DESC=>"Print version and exit"},
    {OPT=>"citation",VAR=>\&show_citation,     DESC=>"Print citation for referencing $EXE"},
    {OPT=>"quiet!",  VAR=>\$quiet, DESC=>"No screen output"},
    {OPT=>"debug!",  VAR=>\$debug, DESC=>"Debug mode"},
    'DATABASE',
    {OPT=>"listdb!",VAR=>\&list_dbs, DESC=>"Show installed database"},
    {OPT=>"updatedb!",VAR=>\&update_dbs, DESC=>"Update databases from internet"},
    "MODE",
    {OPT=>"kingdom=s", VAR=>\$kingdom, DEFAULT=>'bac', DESC=>"Kingdom: ".join(',', keys %KINGDOM) },
    {OPT=>"rrna!",  VAR=>\$rrna,  DEFAULT=>1, DESC=>"Scan for rRNA, disable with -no-rrna" },
    {OPT=>"trna!",  VAR=>\$trna,  DEFAULT=>0, DESC=>"Scan for tRNA/tmRNA" },
    {OPT=>"ncrna!", VAR=>\$ncrna, DEFAULT=>0, DESC=>"Scan for ncRNA" },
    {OPT=>"operon!", VAR=>\$operon, DEFAULT=>0, DESC=>"Idenitfy RNA opersons" },
    {OPT=>"opdist=i", VAR=>\$opdist, DEFAULT=>200,  DESC=>"Operon clustering threshold" },
    "SPEED",
    {OPT=>"threads=i", VAR=>\$threads, DEFAULT=>1,  DESC=>"CPU cores to use"},
    {OPT=>"fast!", VAR=>\$fast, DEFAULT=>undef,  DESC=>"Trade speed for accuracy"},
    "FILTERING",
    {OPT=>"lencutoff=f",VAR=>\$lencutoff, DEFAULT=>0.8, DESC=>"Proportional length threshold to label as partial"},
    {OPT=>"reject=f",VAR=>\$reject, DEFAULT=>0.25, DESC=>"Proportional length threshold to reject prediction"},
    {OPT=>"evalue=f",VAR=>\$evalue, DEFAULT=>0.001, DESC=>"Similarity e-value cut-off"},
    "GFF OUTPUT",
    {OPT=>"addids!",  VAR=>\$addids,  DESC=>"Add unique ID tagsn" },
    {OPT=>"incseq!",  VAR=>\$incseq,  DESC=>"Include original input sequences"},
    {OPT=>"incseqreg!",  VAR=>\$incseqreg,  DESC=>"Include #sequence-region headers"},
    {OPT=>"outseq=s",  VAR=>\$outseq,  DESC=>"Save RNA hits to a FASTA file"},
  );

#  (!@ARGV) && (usage(1));

  &GetOptions(map {$_->{OPT}, $_->{VAR}} grep { ref } @Options) || usage(1);

  # Now setup default values.
  foreach (@Options) {
    if (ref $_ && defined($_->{DEFAULT}) && !defined(${$_->{VAR}})) {
      ${$_->{VAR}} = $_->{DEFAULT};
    }
  }
}

#----------------------------------------------------------------------
sub usage {
  my($exitcode) = @_;
  $exitcode = 0 if $exitcode eq 'help'; # what gets passed by getopt func ref
  $exitcode ||= 0;
  select STDERR if $exitcode; # write to STDERR if exitcode is error

  print "NAME\n";
  print "  $EXE $VERSION\n";
  print "SYNOPSIS\n";
  print "  $DESC\n";
  print "USAGE\n";
  print "  $EXE [opts] seq.{fa,gbk,fq}[.gz] ... \n";
  foreach (@Options) {
    if (ref $_) {
      my $def = defined $_->{DEFAULT} ? "[$_->{DEFAULT}]" : "";
      my $opt = $_->{OPT};
      if ($opt =~ s/!$//) {
        $def = $_->{DEFAULT} ? "[on]" : "";
      }
      $opt =~ s/=s$/ STR/;
      $opt =~ s/=i$/ INT/;
      $opt =~ s/=f$/ NUM/;
      printf "  --%-13s %s %s\n", $opt, $_->{DESC}, $def;
    }
    else {
      print "$_\n";
    }
  }
  print "HOMEPAGE\n";
  print "  $URL";
  exit($exitcode);
}

#---------------------------------------------------------------------
