#!/usr/bin/env perl
use 5.18.0;
use strict;
use warnings;
use Cwd qw"fast_abs_path";
use List::Util qw"min max";
use List::MoreUtils qw"uniq";
use FindBin;
use File::Temp qw"tempdir";
use File::Basename;
use JSON::PP;
use Data::Dumper;

# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
# global variables

my $VERSION = "1.0.0-dev";
my $EXE = $FindBin::RealScript;
my $DESC = "rapid ribosomal RNA prediction";
my $AUTHOR = 'Torsten Seemann';
my $URL = 'https://github.com/tseemann/barrnap';
my $DBDIR = fast_abs_path("$FindBin::RealBin/../db");

my $dbs = enumerate_dbs($DBDIR);

my %KINGDOM = (map { $_ => 1 } 
  sort keys %$dbs );

my %TYPE = (map { $_ => 1 } 
  qw"rRNA tRNA ncRNA" );

# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
# command line options

my(@Options, $quiet, $kingdom, $threads, 
  $types, $listdb, $setupdb, $fast,
  $evalue, $lencutoff, $reject, $incseq, $outseq);
setOptions();

# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
# check all is well

@ARGV or err("No input sequence files provided");

msg("This is $EXE $VERSION by $AUTHOR");
msg("Obtained from $URL");

msg("Checking for dependencies:");
require_exe('cmscan', 'bedtools', 
            'aragorn', 'any2fasta');

$threads > 0 or err("Invalid --threads $threads");
$evalue > 0 or err("Invalid --evalue $evalue");
$lencutoff > 0 or err("Invalid --lencutoff $lencutoff");
$reject > 0 or err("Invalid --reject cutoff $reject");

exists $KINGDOM{$kingdom} or
  err("Imvalid --kingdom '$kingdom'. Try:", values(%KINGDOM) );
# FIXME: store with --kingdom database  
my $code = $kingdom =~ m/^(bac|arc)$/ ? 11 : 1;

my @type = split m/\W+/, $types;
for my $t (@type) {
  exists $TYPE{$t} or err("Invalid --type $t");
}

my @infile = map { File::Spec->rel2abs($_) } uniq @ARGV;
@infile or err("No input sequence files provided");

my $tempdir = tempdir(CLEANUP=>1);
#my $tempdir = ".";
chdir($tempdir);

# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
# LOOP OVER FILES & MODELS
my @fasta;
my @gff;
for my $infile (@infile) {
  -r $infile or err("Can't read '$infile'");
  msg("Using: $infile");
  my $fasta = basename($infile).".fasta";
  my $a2f_opt = $quiet ? '-q' : '';
  run_cmd("any2fasta -u $a2f_opt '$infile' > '$fasta'");
  push @fasta, $fasta;
  for my $type (@type) {
    if ($type eq 'tRNA') {
      my $ara_file = trna_scan($fasta,$code,$type);
      push @gff, parse_aragorn($ara_file);
    }
    else {
      my $tbl_file = cm_scan($fasta, $kingdom, $type);
      push @gff,parse_cmscan($tbl_file, $type);
    }
  }
}

@fasta or err("No valid input files provided");
msg("Found", 0+@gff, "@type features.");


write_gff(\*STDOUT, \@fasta, \@gff);

msg("Done.");

#----------------------------------------------------------------------
sub gff_sort {
  # sort by seqid, then start pos
  return ($a->[0] cmp $b->[0]) || ($a->[3] <=> $b->[3]);
}
#----------------------------------------------------------------------
sub write_gff {
  my($fh, $fasta, $feats) = @_;
  select $fh;
  print "##gff-version 3\n";
  for my $row (sort { &gff_sort } @$feats) {
     print join("\t", @$row),"\n";
  }
  if ($incseq) {
    print "##FASTA\n";
    for my $fa (@$fasta) {
      run_cmd("seqkit seq -w 60 '$fa'");
    }
  }
# if ($outseq) {
#   msg("Writing hit sequences to: $outseq");
#   my $bed = File::Temp->new();
#   for my $b (@bed) {
#     print $bed join("\t", @$b),"\n";
#   }
#   $bed->seek(0, SEEK_END); # rewind
#   my $cmd = "bedtools getfasta -s -name+ -fo '$outseq' -fi '$fasta' -bed '".$bed->filename."'";
#   run_cmd($cmd);

}
#----------------------------------------------------------------------
sub parse_aragorn {
  my($fname) = @_;
  my @gff;
  #>AL123456
  #54 genes found
  #1   tRNA-Ile    [10887,10961] 35   (gat)
  #2   tRNA-Ala    [11112,11185] 34   (tgc)
  #3   tRNA-Leu    [25644,25728] 34   (cag
  #4   tRNA-Ser   c[243100,243188] 35 (gga)
  open my $fh, '<', $fname;
  my $seqid;
  while (<$fh>) {
    chomp;
    if (m/^>(\S+)/) {
      $seqid = $1;
    }
    elsif (m/found/) {
      msg("aragorn: $_");
    }
    else {
      my @x = split ' ', $_;
      $x[2] =~ m/(c?)\[(\d+),(\d+)\]/;
      my($begin,$end) = ($2,$3);
      my $strand = $1 ? '-' : '+';
      my $type = $x[1]; 
      $type =~ s/-.*$//;
      push @gff, [
        $seqid,
        "$EXE:$VERSION",
        $type, 
        $begin, $end, 
        $x[3], 
        $strand, 
        '.',
        "Name=$x[1];note=$x[4]"
      ];
    }
  }
  return @gff;
}
#----------------------------------------------------------------------
sub parse_cmscan {
  my($fname, $ftype) = @_;
  my $dpos = -1;
#  my @bed;
  my @gff;
  open my $fh, '<', $fname;
  while (<$fh>) {
    chomp;
    if (m/#target/) {
      # we are in the header
      $dpos = index($_, "description");
      $dpos > 0 or err("Bad header: $_");
    }
    next if m/^#/;    # comment line
    next if m/^\s*$/; # empty line
    
    my $prod = substr($_, $dpos);
    my @x = split ' ', $_;
    #for my $i (0 .. $#x) {
    #  print "[$i] $x[$i]\n";
    #} 
    $x[9] =~ m/^[+-]$/ or err("Bad hit line: @x");
    my($begin,$end,$strand) = $x[7] < $x[8] 
                            ? ($x[7],$x[8],'+') 
                            : ($x[8],$x[7],'-');
    my($seqid, $acc, $gene) = ($x[2], $x[1], $x[0]);
    my $score = defined $x[14]  ? $x[14] : '.';
    my $len = $end-$begin+1;
    # record hits for --outseq retrieval later
    #  $hitname{"$seqid/$begin:$end($strand)"} = $prod;

    # keep track of good hits for retrievel later
 #   push @bed, [ $seqid, $begin-1, $end, $gene, 100, $strand ];

    msg("Found:", $gene, $seqid, "L=$len", "$begin..$end", $strand, $prod);

    push @gff, [
      $seqid, 
      "$EXE:$VERSION", 
      $ftype,
      $begin, $end, $score, $strand,'.', 
        "Name=$gene"
       .";db_xref=Rfam:$acc"
       .";product=$prod"
    ];
  }
  return @gff;
}

#----------------------------------------------------------------------
sub run_cmd {
  my($cmd) = @_;
  msg("Running: $cmd");
  system($cmd)==0 or err("COuld not run: $cmd");
}
#----------------------------------------------------------------------
sub cm_scan {
  my($fasta, $king, $feat) = @_;
  my $outfile = "$fasta.$king.$feat.out";
  my $speed = $fast ? "--hmmonly" : "--rfam -g";
  my $cmd = "cmscan $speed";
  $cmd .= " --cpu $threads -E $evalue";
  $cmd .= " --noali --acc";
  $cmd .= " --tblout $outfile";
  $cmd .= " -o ".File::Spec->devnull;
  # the 2 positional parametrs
  $cmd .= " $DBDIR/$king/$king.$feat.cm";
  $cmd .= " $fasta";
  run_cmd($cmd);
  return $outfile;
}
#----------------------------------------------------------------------
sub trna_scan {
  my($fasta, $code, $type) = @_;
  my $outfile = "$fasta.$type.out";
  my $cmd = "aragorn -w -gc$code -o '$outfile' '$fasta'";
  run_cmd($cmd);
  return $outfile;
}
#----------------------------------------------------------------------
sub enumerate_dbs {
  my($dir) = @_;
  my $db = {};
  for my $cm (glob("$dir/*/*.cm")) {
    #msg("* $cm");
    $cm =~ m=(\w+)\.(\w+)\.cm$= or err("Bad mode; $cm");
    $db->{$1}{$2} = $cm;
  }
  return $db;
}
#----------------------------------------------------------------------
sub list_dbs {
  my $dbs = enumerate_dbs($DBDIR);
  #print Dumper($dbs);
  msg("Database home: $DBDIR");
  msg("Kingdoms:",sort keys %$dbs);
  exit(0);
}
#----------------------------------------------------------------------
sub setup_dbs {
  msg("Make indicesin $DBDIR");
  run_cmd("find '$DBDIR' -name '*.cm' -exec cmpress -F {} \\;");
  msg("Indexed databases.");
  exit(0);
}
#----------------------------------------------------------------------
sub require_exe {
  for my $exe (@_) {
    my($which) = qx(which $exe 2> /dev/null);
    $which or err("Can not find required '$exe' in PATH");
    chomp $which;
    msg("Found $exe - $which");
  }
}
#----------------------------------------------------------------------
sub revcom {
  my($s) = @_;
  $s = reverse($s);
  $s =~ tr/ATCGatcg/TAGCtagc/;
  return $s;
}
#----------------------------------------------------------------------
sub msg {
  return if $quiet;
  my $line = "[$EXE] @_\n";
  print STDERR $line;
}
#----------------------------------------------------------------------
sub err {
  $quiet=0;
  msg("ERROR:", @_);
  exit(2);
}
#----------------------------------------------------------------------
sub version {
  print "$EXE $VERSION\n";
  exit;
}
#----------------------------------------------------------------------
sub show_citation {
  print STDERR << "EOCITE";
  
If you use Barrnap in your work, please cite:

    Seemann T
    $EXE $VERSION : $DESC
    $URL
    
Thank you.

EOCITE

  exit;
}
#----------------------------------------------------------------------
# Option setting routines

sub setOptions {
  use Getopt::Long;

  @Options = (
    'GENERAL',
    {OPT=>"help",    VAR=>\&usage,             DESC=>"This help"},
    {OPT=>"version", VAR=>\&version,           DESC=>"Print version and exit"},
    {OPT=>"citation",VAR=>\&show_citation,     DESC=>"Print citation for referencing $EXE"},
    {OPT=>"quiet!",  VAR=>\$quiet, DEFAULT=>0, DESC=>"No screen output"},
    'DATABASE',
    {OPT=>"listdb",VAR=>\&list_dbs, DESC=>"Descube installed database"},
    {OPT=>"setupdb",VAR=>\&setup_dbs, DESC=>"Setup install databases"},
    {OPT=>"kingdom=s", VAR=>\$kingdom, DEFAULT=>'bac', DESC=>"Kingdom: ".join(' ', values %KINGDOM) },
    {OPT=>"types=s", VAR=>\$types,  DEFAULT=>'rRNA', DESC=>"Features: ".join(' ', keys %TYPE) },
    "SPEED",
    {OPT=>"threads=i",  VAR=>\$threads, DEFAULT=>1,  DESC=>"Number of threads/cores/CPUs to use"},
    {OPT=>"fast!",  VAR=>\$fast, DEFAULT=>undef,  DESC=>"Trade speed for accuracy"},
    "OUTPUT",
    {OPT=>"lencutoff=f",VAR=>\$lencutoff, DEFAULT=>0.8, DESC=>"Proportional length threshold to label as partial"},
    {OPT=>"reject=f",VAR=>\$reject, DEFAULT=>0.25, DESC=>"Proportional length threshold to reject prediction"},
    {OPT=>"evalue=f",VAR=>\$evalue, DEFAULT=>"0.001", DESC=>"Similarity e-value cut-off"},
    {OPT=>"incseq!",  VAR=>\$incseq, DEFAULT=>0, DESC=>"Include FASTA _input_ sequences in GFF3 output"},
    {OPT=>"outseq=s",  VAR=>\$outseq, DEFAULT=>'', DESC=>"Save rRNA hit seqs to this FASTA file"},
  );

#  (!@ARGV) && (usage(1));

  &GetOptions(map {$_->{OPT}, $_->{VAR}} grep { ref } @Options) || usage(1);

  # Now setup default values.
  foreach (@Options) {
    if (ref $_ && defined($_->{DEFAULT}) && !defined(${$_->{VAR}})) {
      ${$_->{VAR}} = $_->{DEFAULT};
    }
  }
}

#----------------------------------------------------------------------
sub usage {
  my($exitcode) = @_;
  $exitcode = 0 if $exitcode eq 'help'; # what gets passed by getopt func ref
  $exitcode ||= 0;
  select STDERR if $exitcode; # write to STDERR if exitcode is error

  print "NAME\n";
  print "  $EXE $VERSION\n";
  print "SYNOPSIS\n";
  print "  $DESC\n";
  print "USAGE\n";
  print "  $EXE [opts] genome.fasta ...\n";
  foreach (@Options) {
    if (ref) {
      my $def = defined($_->{DEFAULT}) ? " (default '$_->{DEFAULT}')" : "";
      $def = ($def ? ' (default OFF)' : '(default ON)') if $_->{OPT} =~ m/!$/;
      my $opt = $_->{OPT};
      $opt =~ s/!$//; 
      $opt =~ s/=s$/ [X]/; 
      $opt =~ s/=i$/ [N]/;
      $opt =~ s/=f$/ [n.n]/;
      printf "  --%-15s %s%s\n", $opt, $_->{DESC}, $def;
    }
    else {
      print "$_\n";
    }      
  }
  print "HOMEPAGE\n";
  print "  $URL";
  exit($exitcode);
}

#---------------------------------------------------------------------